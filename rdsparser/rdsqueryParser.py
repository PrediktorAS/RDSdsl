# Generated from rdsquery.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\34")
        buf.write("\u0084\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\3\2\6\2\32")
        buf.write("\n\2\r\2\16\2\33\3\2\3\2\3\2\3\2\3\2\3\2\3\3\3\3\5\3&")
        buf.write("\n\3\3\4\6\4)\n\4\r\4\16\4*\3\4\3\4\5\4/\n\4\3\5\3\5\5")
        buf.write("\5\63\n\5\3\5\3\5\3\5\5\58\n\5\5\5:\n\5\3\6\6\6=\n\6\r")
        buf.write("\6\16\6>\3\6\6\6B\n\6\r\6\16\6C\3\6\6\6G\n\6\r\6\16\6")
        buf.write("H\3\6\6\6L\n\6\r\6\16\6M\5\6P\n\6\3\7\3\7\5\7T\n\7\3\b")
        buf.write("\3\b\7\bX\n\b\f\b\16\b[\13\b\3\b\3\b\3\b\3\b\3\b\3\b\5")
        buf.write("\bc\n\b\3\b\7\bf\n\b\f\b\16\bi\13\b\3\b\3\b\5\bm\n\b\3")
        buf.write("\t\3\t\7\tq\n\t\f\t\16\tt\13\t\3\t\3\t\5\tx\n\t\3\n\3")
        buf.write("\n\3\n\3\13\3\13\3\13\3\f\3\f\3\f\3\f\3\f\2\2\r\2\4\6")
        buf.write("\b\n\f\16\20\22\24\26\2\2\2\u0091\2\31\3\2\2\2\4%\3\2")
        buf.write("\2\2\6(\3\2\2\2\b\60\3\2\2\2\nO\3\2\2\2\fS\3\2\2\2\16")
        buf.write("U\3\2\2\2\20r\3\2\2\2\22y\3\2\2\2\24|\3\2\2\2\26\177\3")
        buf.write("\2\2\2\30\32\5\4\3\2\31\30\3\2\2\2\32\33\3\2\2\2\33\31")
        buf.write("\3\2\2\2\33\34\3\2\2\2\34\35\3\2\2\2\35\36\7\3\2\2\36")
        buf.write("\37\5\26\f\2\37 \3\2\2\2 !\7\4\2\2!\"\5\26\f\2\"\3\3\2")
        buf.write("\2\2#&\5\6\4\2$&\5\24\13\2%#\3\2\2\2%$\3\2\2\2&\5\3\2")
        buf.write("\2\2\')\5\b\5\2(\'\3\2\2\2)*\3\2\2\2*(\3\2\2\2*+\3\2\2")
        buf.write("\2+,\3\2\2\2,.\7\5\2\2-/\5\f\7\2.-\3\2\2\2./\3\2\2\2/")
        buf.write("\7\3\2\2\2\60\62\5\n\6\2\61\63\7\6\2\2\62\61\3\2\2\2\62")
        buf.write("\63\3\2\2\2\639\3\2\2\2\64:\7\33\2\2\65\67\7\22\2\2\66")
        buf.write("8\7\33\2\2\67\66\3\2\2\2\678\3\2\2\28:\3\2\2\29\64\3\2")
        buf.write("\2\29\65\3\2\2\2:\t\3\2\2\2;=\7\7\2\2<;\3\2\2\2=>\3\2")
        buf.write("\2\2><\3\2\2\2>?\3\2\2\2?P\3\2\2\2@B\7\b\2\2A@\3\2\2\2")
        buf.write("BC\3\2\2\2CA\3\2\2\2CD\3\2\2\2DP\3\2\2\2EG\7\t\2\2FE\3")
        buf.write("\2\2\2GH\3\2\2\2HF\3\2\2\2HI\3\2\2\2IP\3\2\2\2JL\7\n\2")
        buf.write("\2KJ\3\2\2\2LM\3\2\2\2MK\3\2\2\2MN\3\2\2\2NP\3\2\2\2O")
        buf.write("<\3\2\2\2OA\3\2\2\2OF\3\2\2\2OK\3\2\2\2P\13\3\2\2\2QT")
        buf.write("\5\20\t\2RT\5\16\b\2SQ\3\2\2\2SR\3\2\2\2T\r\3\2\2\2UY")
        buf.write("\5\20\t\2VX\7\13\2\2WV\3\2\2\2X[\3\2\2\2YW\3\2\2\2YZ\3")
        buf.write("\2\2\2Zb\3\2\2\2[Y\3\2\2\2\\c\7\7\2\2]c\7\f\2\2^c\7\r")
        buf.write("\2\2_c\7\16\2\2`c\7\17\2\2ac\7\20\2\2b\\\3\2\2\2b]\3\2")
        buf.write("\2\2b^\3\2\2\2b_\3\2\2\2b`\3\2\2\2ba\3\2\2\2cg\3\2\2\2")
        buf.write("df\7\13\2\2ed\3\2\2\2fi\3\2\2\2ge\3\2\2\2gh\3\2\2\2hl")
        buf.write("\3\2\2\2ig\3\2\2\2jm\5\22\n\2km\7\27\2\2lj\3\2\2\2lk\3")
        buf.write("\2\2\2m\17\3\2\2\2no\7\33\2\2oq\7\21\2\2pn\3\2\2\2qt\3")
        buf.write("\2\2\2rp\3\2\2\2rs\3\2\2\2sw\3\2\2\2tr\3\2\2\2ux\7\33")
        buf.write("\2\2vx\7\22\2\2wu\3\2\2\2wv\3\2\2\2x\21\3\2\2\2yz\7\22")
        buf.write("\2\2z{\5\20\t\2{\23\3\2\2\2|}\7\22\2\2}~\5\f\7\2~\25\3")
        buf.write("\2\2\2\177\u0080\7\25\2\2\u0080\u0081\7\13\2\2\u0081\u0082")
        buf.write("\7\26\2\2\u0082\27\3\2\2\2\25\33%*.\62\679>CHMOSYbglr")
        buf.write("w")
        return buf.getvalue()


class rdsqueryParser ( Parser ):

    grammarFileName = "rdsquery.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'from '", "'to '", "'/'", "'...'", "'='", 
                     "'-'", "'+'", "'#'", "' '", "'>'", "'<'", "'>='", "'<='", 
                     "'!='", "'.'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "GLUE", "TIME_OFFSET", "PARTIAL_TIME", "FULL_DATE", 
                      "FULL_TIME", "LITERAL", "REAL", "INTEGER", "BOOLEAN", 
                      "ID", "WS" ]

    RULE_rdsQuery = 0
    RULE_queryExpression = 1
    RULE_designationExpr = 2
    RULE_singleDesignation = 3
    RULE_aspectPrefix = 4
    RULE_signalExpr = 5
    RULE_signalCondExpr = 6
    RULE_signalPath = 7
    RULE_gluedSignalPath = 8
    RULE_gluedSignalExpr = 9
    RULE_dateTime = 10

    ruleNames =  [ "rdsQuery", "queryExpression", "designationExpr", "singleDesignation", 
                   "aspectPrefix", "signalExpr", "signalCondExpr", "signalPath", 
                   "gluedSignalPath", "gluedSignalExpr", "dateTime" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    GLUE=16
    TIME_OFFSET=17
    PARTIAL_TIME=18
    FULL_DATE=19
    FULL_TIME=20
    LITERAL=21
    REAL=22
    INTEGER=23
    BOOLEAN=24
    ID=25
    WS=26

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class RdsQueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.fromdt = None # DateTimeContext
            self.todt = None # DateTimeContext

        def queryExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(rdsqueryParser.QueryExpressionContext)
            else:
                return self.getTypedRuleContext(rdsqueryParser.QueryExpressionContext,i)


        def dateTime(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(rdsqueryParser.DateTimeContext)
            else:
                return self.getTypedRuleContext(rdsqueryParser.DateTimeContext,i)


        def getRuleIndex(self):
            return rdsqueryParser.RULE_rdsQuery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRdsQuery" ):
                listener.enterRdsQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRdsQuery" ):
                listener.exitRdsQuery(self)




    def rdsQuery(self):

        localctx = rdsqueryParser.RdsQueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_rdsQuery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 23 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 22
                self.queryExpression()
                self.state = 25 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << rdsqueryParser.T__4) | (1 << rdsqueryParser.T__5) | (1 << rdsqueryParser.T__6) | (1 << rdsqueryParser.T__7) | (1 << rdsqueryParser.GLUE))) != 0)):
                    break

            self.state = 27
            self.match(rdsqueryParser.T__0)
            self.state = 28
            localctx.fromdt = self.dateTime()

            self.state = 30
            self.match(rdsqueryParser.T__1)
            self.state = 31
            localctx.todt = self.dateTime()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryExpressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def designationExpr(self):
            return self.getTypedRuleContext(rdsqueryParser.DesignationExprContext,0)


        def gluedSignalExpr(self):
            return self.getTypedRuleContext(rdsqueryParser.GluedSignalExprContext,0)


        def getRuleIndex(self):
            return rdsqueryParser.RULE_queryExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQueryExpression" ):
                listener.enterQueryExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQueryExpression" ):
                listener.exitQueryExpression(self)




    def queryExpression(self):

        localctx = rdsqueryParser.QueryExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_queryExpression)
        try:
            self.state = 35
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [rdsqueryParser.T__4, rdsqueryParser.T__5, rdsqueryParser.T__6, rdsqueryParser.T__7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 33
                self.designationExpr()
                pass
            elif token in [rdsqueryParser.GLUE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 34
                self.gluedSignalExpr()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DesignationExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.signal_expr = None # SignalExprContext

        def singleDesignation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(rdsqueryParser.SingleDesignationContext)
            else:
                return self.getTypedRuleContext(rdsqueryParser.SingleDesignationContext,i)


        def signalExpr(self):
            return self.getTypedRuleContext(rdsqueryParser.SignalExprContext,0)


        def getRuleIndex(self):
            return rdsqueryParser.RULE_designationExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDesignationExpr" ):
                listener.enterDesignationExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDesignationExpr" ):
                listener.exitDesignationExpr(self)




    def designationExpr(self):

        localctx = rdsqueryParser.DesignationExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_designationExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 38 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 37
                self.singleDesignation()
                self.state = 40 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << rdsqueryParser.T__4) | (1 << rdsqueryParser.T__5) | (1 << rdsqueryParser.T__6) | (1 << rdsqueryParser.T__7))) != 0)):
                    break

            self.state = 42
            self.match(rdsqueryParser.T__2)
            self.state = 44
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,3,self._ctx)
            if la_ == 1:
                self.state = 43
                localctx.signal_expr = self.signalExpr()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SingleDesignationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.prefix = None # AspectPrefixContext
            self.ellipsis = None # Token
            self.identifier = None # Token
            self.glue = None # Token

        def aspectPrefix(self):
            return self.getTypedRuleContext(rdsqueryParser.AspectPrefixContext,0)


        def ID(self):
            return self.getToken(rdsqueryParser.ID, 0)

        def GLUE(self):
            return self.getToken(rdsqueryParser.GLUE, 0)

        def getRuleIndex(self):
            return rdsqueryParser.RULE_singleDesignation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSingleDesignation" ):
                listener.enterSingleDesignation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSingleDesignation" ):
                listener.exitSingleDesignation(self)




    def singleDesignation(self):

        localctx = rdsqueryParser.SingleDesignationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_singleDesignation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 46
            localctx.prefix = self.aspectPrefix()
            self.state = 48
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==rdsqueryParser.T__3:
                self.state = 47
                localctx.ellipsis = self.match(rdsqueryParser.T__3)


            self.state = 55
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [rdsqueryParser.ID]:
                self.state = 50
                localctx.identifier = self.match(rdsqueryParser.ID)
                pass
            elif token in [rdsqueryParser.GLUE]:
                self.state = 51
                localctx.glue = self.match(rdsqueryParser.GLUE)
                self.state = 53
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==rdsqueryParser.ID:
                    self.state = 52
                    localctx.identifier = self.match(rdsqueryParser.ID)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AspectPrefixContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return rdsqueryParser.RULE_aspectPrefix

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAspectPrefix" ):
                listener.enterAspectPrefix(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAspectPrefix" ):
                listener.exitAspectPrefix(self)




    def aspectPrefix(self):

        localctx = rdsqueryParser.AspectPrefixContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_aspectPrefix)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 77
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [rdsqueryParser.T__4]:
                self.state = 58 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 57
                    self.match(rdsqueryParser.T__4)
                    self.state = 60 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==rdsqueryParser.T__4):
                        break

                pass
            elif token in [rdsqueryParser.T__5]:
                self.state = 63 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 62
                    self.match(rdsqueryParser.T__5)
                    self.state = 65 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==rdsqueryParser.T__5):
                        break

                pass
            elif token in [rdsqueryParser.T__6]:
                self.state = 68 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 67
                    self.match(rdsqueryParser.T__6)
                    self.state = 70 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==rdsqueryParser.T__6):
                        break

                pass
            elif token in [rdsqueryParser.T__7]:
                self.state = 73 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 72
                    self.match(rdsqueryParser.T__7)
                    self.state = 75 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==rdsqueryParser.T__7):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignalExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.signal_path = None # SignalPathContext
            self.signal_cond_expr = None # SignalCondExprContext

        def signalPath(self):
            return self.getTypedRuleContext(rdsqueryParser.SignalPathContext,0)


        def signalCondExpr(self):
            return self.getTypedRuleContext(rdsqueryParser.SignalCondExprContext,0)


        def getRuleIndex(self):
            return rdsqueryParser.RULE_signalExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignalExpr" ):
                listener.enterSignalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignalExpr" ):
                listener.exitSignalExpr(self)




    def signalExpr(self):

        localctx = rdsqueryParser.SignalExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_signalExpr)
        try:
            self.state = 81
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 79
                localctx.signal_path = self.signalPath()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 80
                localctx.signal_cond_expr = self.signalCondExpr()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignalCondExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.signal_path = None # SignalPathContext
            self.op = None # Token
            self.glued_signal_path = None # GluedSignalPathContext
            self.literal = None # Token

        def signalPath(self):
            return self.getTypedRuleContext(rdsqueryParser.SignalPathContext,0)


        def gluedSignalPath(self):
            return self.getTypedRuleContext(rdsqueryParser.GluedSignalPathContext,0)


        def LITERAL(self):
            return self.getToken(rdsqueryParser.LITERAL, 0)

        def getRuleIndex(self):
            return rdsqueryParser.RULE_signalCondExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignalCondExpr" ):
                listener.enterSignalCondExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignalCondExpr" ):
                listener.exitSignalCondExpr(self)




    def signalCondExpr(self):

        localctx = rdsqueryParser.SignalCondExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_signalCondExpr)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 83
            localctx.signal_path = self.signalPath()
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==rdsqueryParser.T__8:
                self.state = 84
                self.match(rdsqueryParser.T__8)
                self.state = 89
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 96
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [rdsqueryParser.T__4]:
                self.state = 90
                localctx.op = self.match(rdsqueryParser.T__4)
                pass
            elif token in [rdsqueryParser.T__9]:
                self.state = 91
                localctx.op = self.match(rdsqueryParser.T__9)
                pass
            elif token in [rdsqueryParser.T__10]:
                self.state = 92
                localctx.op = self.match(rdsqueryParser.T__10)
                pass
            elif token in [rdsqueryParser.T__11]:
                self.state = 93
                localctx.op = self.match(rdsqueryParser.T__11)
                pass
            elif token in [rdsqueryParser.T__12]:
                self.state = 94
                localctx.op = self.match(rdsqueryParser.T__12)
                pass
            elif token in [rdsqueryParser.T__13]:
                self.state = 95
                localctx.op = self.match(rdsqueryParser.T__13)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 101
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==rdsqueryParser.T__8:
                self.state = 98
                self.match(rdsqueryParser.T__8)
                self.state = 103
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 106
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [rdsqueryParser.GLUE]:
                self.state = 104
                localctx.glued_signal_path = self.gluedSignalPath()
                pass
            elif token in [rdsqueryParser.LITERAL]:
                self.state = 105
                localctx.literal = self.match(rdsqueryParser.LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignalPathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.glue = None # Token

        def ID(self, i:int=None):
            if i is None:
                return self.getTokens(rdsqueryParser.ID)
            else:
                return self.getToken(rdsqueryParser.ID, i)

        def GLUE(self):
            return self.getToken(rdsqueryParser.GLUE, 0)

        def getRuleIndex(self):
            return rdsqueryParser.RULE_signalPath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSignalPath" ):
                listener.enterSignalPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSignalPath" ):
                listener.exitSignalPath(self)




    def signalPath(self):

        localctx = rdsqueryParser.SignalPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_signalPath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 112
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,17,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 108
                    self.match(rdsqueryParser.ID)
                    self.state = 109
                    self.match(rdsqueryParser.T__14) 
                self.state = 114
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,17,self._ctx)

            self.state = 117
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [rdsqueryParser.ID]:
                self.state = 115
                self.match(rdsqueryParser.ID)
                pass
            elif token in [rdsqueryParser.GLUE]:
                self.state = 116
                localctx.glue = self.match(rdsqueryParser.GLUE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GluedSignalPathContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.glue = None # Token
            self.signal_path = None # SignalPathContext

        def GLUE(self):
            return self.getToken(rdsqueryParser.GLUE, 0)

        def signalPath(self):
            return self.getTypedRuleContext(rdsqueryParser.SignalPathContext,0)


        def getRuleIndex(self):
            return rdsqueryParser.RULE_gluedSignalPath

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGluedSignalPath" ):
                listener.enterGluedSignalPath(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGluedSignalPath" ):
                listener.exitGluedSignalPath(self)




    def gluedSignalPath(self):

        localctx = rdsqueryParser.GluedSignalPathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_gluedSignalPath)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 119
            localctx.glue = self.match(rdsqueryParser.GLUE)
            self.state = 120
            localctx.signal_path = self.signalPath()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class GluedSignalExprContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.glue = None # Token
            self.signal_expr = None # SignalExprContext

        def GLUE(self):
            return self.getToken(rdsqueryParser.GLUE, 0)

        def signalExpr(self):
            return self.getTypedRuleContext(rdsqueryParser.SignalExprContext,0)


        def getRuleIndex(self):
            return rdsqueryParser.RULE_gluedSignalExpr

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGluedSignalExpr" ):
                listener.enterGluedSignalExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGluedSignalExpr" ):
                listener.exitGluedSignalExpr(self)




    def gluedSignalExpr(self):

        localctx = rdsqueryParser.GluedSignalExprContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_gluedSignalExpr)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 122
            localctx.glue = self.match(rdsqueryParser.GLUE)
            self.state = 123
            localctx.signal_expr = self.signalExpr()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateTimeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FULL_DATE(self):
            return self.getToken(rdsqueryParser.FULL_DATE, 0)

        def FULL_TIME(self):
            return self.getToken(rdsqueryParser.FULL_TIME, 0)

        def getRuleIndex(self):
            return rdsqueryParser.RULE_dateTime

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDateTime" ):
                listener.enterDateTime(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDateTime" ):
                listener.exitDateTime(self)




    def dateTime(self):

        localctx = rdsqueryParser.DateTimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_dateTime)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 125
            self.match(rdsqueryParser.FULL_DATE)
            self.state = 126
            self.match(rdsqueryParser.T__8)
            self.state = 127
            self.match(rdsqueryParser.FULL_TIME)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





